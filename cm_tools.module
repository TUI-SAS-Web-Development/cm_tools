<?php
/**
 * @file
 * The Computerminds tools module.
 *
 * We'll try to keep this file as lean as possible, and do as much as possible
 * in includes.
 *
 * This file contains hook implementations and helpers likely to be used on
 * every page request.
 */

/**
 * @class CM
 * Holds all helper methods likely to be used on every, or most, page loads.
 */
class CM {

	/**
	 * Inserts one or more suggestions into a theme_hook_suggestions array.
	 *
	 * @param $haystack
	 *   The $vars['theme_hook_suggestions'] array. It is modified by reference.
	 * @param $insert_value
	 *   String value after which to insert $suggestions. May also be an array of
	 *   suggested values in which case the first one to be found will be used.
	 * @param array $suggestions
	 *   A single new suggestion, or array of new suggestions to insert.
	 * @param bool $insert_before
	 *   (Optional) Change the behaviour of this function to insert *before*
	 *   $insert_value instead of after it.
	 * @param bool|true $append_on_fail
	 *   (Optional) By default this function will append the $suggestions on the end
	 *   of $haystack if $insert_value could not be found. Pass FALSE here to stop
	 *   this and make this function return FALSE in this case.
	 *
	 * @return bool
	 *   Success, either TRUE or FALSE.
	 */
	public static function insertThemeHookSuggestion(&$haystack, $insert_value, $suggestions, $insert_before = FALSE, $append_on_fail = TRUE) {

		if (!is_array($insert_value)) {
			$insert_value = array($insert_value);
		}

		$success = FALSE;
		foreach ($insert_value as $v) {
			if (CM::arrayInsertAtValue($haystack, $v, $suggestions, $insert_before, FALSE)) {
				$success = TRUE;
				break;
			}
		}

		if (!$success && $append_on_fail) {
			if (!is_array($suggestions)) {
				$suggestions = array($suggestions);
			}
			$haystack = array_merge(array_values($haystack), array_values($suggestions));
			$success = TRUE;
		}

		return $success;
	}

	/**
	 * Renames an array key while leaving it in exactly the same place in the array.
	 *
	 * @param $haystack
	 *   The array. This is modified by reference.
	 * @param $key
	 *   The key to rename.
	 * @param $new_key
	 *   The new name for the key. If this already exists in the array it will be
	 *   overwritten.
	 *
	 * @return bool
	 *   Success, either TRUE or FALSE.
	 */
	public static function arrayRenameKey(&$haystack, $key, $new_key) {
		$success = FALSE;

		if (isset($haystack[$key])) {
			$insertion = array(
				$new_key => $haystack[$key],
			);
			if ($success = CM::arrayInsertAtKey($haystack, $key, $insertion)) {
				if ($key !== $new_key) {
					unset($haystack[$key]);
				}
			}
		}

		return $success;
	}

	/**
	 * Inserts a new element into an array, just after the one with the given value.
	 *
	 * The insert value is found by *strict* comparison. If multiple values are
	 * found the insertion will be made next to the first occurance only.
	 *
	 * @param $haystack
	 *   The array. This is modified by reference.
	 * @param $insert_value
	 *   Array value after which to insert $insertion. A *strict* comparison is
	 *   performed when searching for this value.
	 * @param array $insertions
	 *   Array of new values to insert into the array. If $preserve_keys is TRUE and
	 *   an element already exists in the array with the same key as one you are
	 *   inserting, the old one(s) will removed. If this parameter is not an array
	 *   it will be inserted into the array with the lowest available numeric key.
	 * @param bool $insert_before
	 *   (Optional) Change the behaviour of this function to insert *before*
	 *   $insert_value instead of after it.
	 * @param bool $preserve_keys
	 *   (Optional) By default this function ignores keys, giving everything a new
	 *   numeric index. Pass TRUE here to indicate that all keys should be
	 *   preserved.
	 *
	 * @return bool
	 *   Success, either TRUE or FALSE.
	 */
	public static function arrayInsertAtValue(&$haystack, $insert_value, $insertions, $insert_before = FALSE, $preserve_keys = FALSE) {
		$success = FALSE;
		$insert_key = array_search($insert_value, $haystack, TRUE);
		if ($insert_key !== FALSE) {
			$success = CM::arrayInsertAtKey($haystack, $insert_key, $insertions, $insert_before, $preserve_keys);
		}
		return $success;
	}

	/**
	 * Inserts a new element into an array, just after the one with the given key.
	 *
	 * The insert key is found by *strict* comparison.
	 *
	 * @param $haystack
	 *   The array. This is modified by reference.
	 * @param $insert_key
	 *   Array key after which to insert $insertion. This can also be an array of
	 *   suggested keys, in which case each will be looked for in turn and the
	 *   first existing one will be used. A *strict* comparison is performed when
	 *   searching for this key.
	 * @param array $insertions
	 *   Array of new values to insert into the array. Unless $preserve_keys is
	 *   FALSE if an element already exists in the array with the same key as one
	 *   you are inserting, the old one(s) will removed. If this parameter is not an
	 *   array it will be inserted into the array with the lowest available numeric
	 *   key.
	 * @param bool $insert_before
	 *   (Optional) Change the behaviour of this function to insert *before*
	 *   $insert_key instead of after it.
	 * @param bool|true $preserve_keys
	 *   (Optional) By default this function always preserves keys, even for
	 *   numerically-indexed arrays. Pass FALSE here if using a numerically-indexed
	 *   array and you don't want to overwrite elements.
	 *
	 * @return bool
	 *   Success, either TRUE or FALSE.
	 */
	public static function arrayInsertAtKey(&$haystack, $insert_key, $insertions, $insert_before = FALSE, $preserve_keys = TRUE) {

		$success = FALSE;

		if (!is_array($insert_key)) {
			$insert_key = array($insert_key);
		}

		$haystack_keys = array_keys($haystack);
		$offset = FALSE;
		while (count($insert_key) && $offset === FALSE) {
			$loc = array_shift($insert_key);
			$offset = array_search($loc, $haystack_keys, TRUE);
		}

		if ($offset !== FALSE) {
			if ($insert_before) {
				$offset = $offset - 1;
			}
			$success = CM::arrayInsertAtOffset($haystack, $offset + 1, $insertions, $preserve_keys);
		}

		return $success;
	}

	/**
	 * Inserts a new element at an offset in an array.
	 *
	 * @param $haystack
	 *   The array. This is modified by reference.
	 * @param $offset
	 *   Offset after which to insert $insertion.
	 * @param Array $insertions
	 *   Array of new values to insert into the array. If $preserve_keys is TRUE and
	 *   an element already exists in the array with the same key as one you are
	 *   inserting, the old one(s) will removed. If this parameter is not an array
	 *   it will be inserted into the array with the lowest available numeric key.
	 * @param bool $preserve_keys
	 *   (Optional) By default this function ignores keys, giving everything a new
	 *   numeric index. Pass TRUE here to indicate that all keys should be
	 *   preserved.
	 *
	 * @return bool
	 *   Success, either TRUE or FALSE.
	 */
	public static function arrayInsertAtOffset(&$haystack, $offset, $insertions, $preserve_keys = FALSE) {

		$success = FALSE;

		if (!is_integer($offset)) {
			return FALSE;
		}

		if (!$preserve_keys) {
			$haystack = array_values($haystack);
		}

		// Insertions not given as an array. Give it the lowest available numeric key.
		if (!is_array($insertions)) {
			$numeric_keys = array_filter(array_keys($haystack), 'is_numeric');
			$unique_key = !empty($numeric_keys) ? max($numeric_keys) + 1 : 0;
			$insertions = array($unique_key => $insertions);
		}

		if (!$preserve_keys) {
			$insertions = array_values($insertions);
		}

		// Wipe out any keys we're about to overwrite, and ensure we modify the
		// $offset to take into account the changed $haystack.
		if ($preserve_keys) {
			$o = 0;
			foreach (array_keys($haystack) as $k) {
				if (isset($insertions[$k])) {
					if ($o < $offset) {
						$offset--;
					}
					unset($haystack[$k]);
				}
				$o++;
			}
		}

		$before = array_slice($haystack, 0, $offset, TRUE);
		$after = array_slice($haystack, $offset, count($haystack), TRUE);

		if (!$preserve_keys) {
			$haystack = array_merge($before, $insertions, $after);
			$success = TRUE;
		}
		else {
			$keys = array_merge(array_keys($before), array_keys($insertions), array_keys($after));
			$values = array_merge($before, $insertions, $after);
			$haystack = array_combine($keys, $values);
			$success = TRUE;
		}

		return $success;
	}

}

/**
 * Implements hook_theme().
 */
function cm_tools_theme($existing, $type, $theme, $path) {
  $items = array(
    'cm_tools_html_wrapper' => array(
	    'render element' => 'element',
      'file' => 'cm_tools.theme.inc',
		),
  );
  return $items;
}

/**
 * Implements hook_preprocess_entity().
 */
function cm_tools_preprocess_entity(&$vars, $hook) {

	$entity_type = $vars['entity_type'];

	$view_mode = isset($vars['view_mode']) ? $vars['view_mode'] : 'full';

	if (isset($vars[$entity_type]) && is_object($vars[$entity_type])) {
		$entity = $vars[$entity_type];
		list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

		if (empty($bundle)) {
			$bundle = $entity_type;
		}

		// Ensure theme_hook_suggestions for id, bundle and view_mode
		$suggestion = "{$entity_type}__{$bundle}";
		if (!in_array($suggestion, $vars['theme_hook_suggestions'])) {
			array_unshift($vars['theme_hook_suggestions'], $suggestion);
		}
		$suggestion = "{$entity_type}__{$view_mode}";
		if (!in_array($suggestion, $vars['theme_hook_suggestions'])) {
			CM::insertThemeHookSuggestion($vars['theme_hook_suggestions'], "{$entity_type}__{$bundle}", $suggestion);
		}
		$suggestion = "{$entity_type}__{$bundle}__{$view_mode}";
		if (!in_array($suggestion, $vars['theme_hook_suggestions'])) {
			CM::insertThemeHookSuggestion($vars['theme_hook_suggestions'], "{$entity_type}__{$view_mode}", $suggestion);
		}
		$suggestion = "{$entity_type}__{$id}";
		if (!in_array($suggestion, $vars['theme_hook_suggestions'])) {
			$vars['theme_hook_suggestions'][] = $suggestion;
		}
		$suggestion = "{$entity_type}__{$id}__{$view_mode}";
		if (!in_array($suggestion, $vars['theme_hook_suggestions'])) {
			CM::insertThemeHookSuggestion($vars['theme_hook_suggestions'], "{$entity_type}__{$id}", $suggestion);
		}
	}
}

/**
 * Implements hook_preprocess_comment().
 */
function cm_tools_preprocess_comment(&$vars, $hook) {
	$vars['entity_type'] = 'comment';
  cm_tools_preprocess_entity($vars, $hook);
}

/**
 * Implements hook_preprocess_node().
 */
function cm_tools_preprocess_node(&$vars, $hook) {
	$vars['entity_type'] = 'node';
  cm_tools_preprocess_entity($vars, $hook);
}

/**
 * Implements hook_preprocess_taxonomy_term().
 */
function cm_tools_preprocess_taxonomy_term(&$vars, $hook) {
	$vars['entity_type'] = 'taxonomy_term';
  cm_tools_preprocess_entity($vars, $hook);
}

/**
 * Implements hook_preprocess_taxonomy_vocabulary().
 */
function cm_tools_preprocess_taxonomy_vocabulary(&$vars, $hook) {
	$vars['entity_type'] = 'taxonomy_vocabulary';
  cm_tools_preprocess_entity($vars, $hook);
}

/**
 * Implements hook_preprocess_user().
 */
function cm_tools_preprocess_user(&$vars, $hook) {
	$vars['entity_type'] = 'user';
  cm_tools_preprocess_entity($vars, $hook);
}
